---
title: "Transformer"
date: 2025-08-22 10:00:00 +0800
categories: [AI, Models] #[Top_category, sub_category]
tags: [ai, models] ## TAG names should always be lowercase
# author: 
---

1.请你解释一下 Transformer 的注意力机制是如何实现的？
A: Transformer 中的注意力机制主要是 “Scaled Dot-Product Attention”，它是模型学习“当前词与其他词之间的关联”的核心模块![img-description](/assets/img/attention_formula.png)

2. Transformer 的注意力机制如何实现？
Transformer 中的注意力实现是 Scaled Dot-Product Attention，它的计算过程是：
	0.	首先将输入嵌入分别映射为 Query、Key 和 Value 向量；
	0.	对 Query 和 Key 做点积，得到注意力分数；
	0.	使用 Softmax 对这些分数进行归一化，得到注意力权重；
	0.	用权重对 Value 做加权平均，得到输出。


3. Q, K, V 的含义和获取方式？（分别乘以3个不同的权重矩阵）
Q、K、V 分别表示查询（Query）、键（Key）和值（Value），它们分别表示：
	•	Q：当前词在关注其他词时，发出的“查询请求”
	•	K：被其他词查询的“身份特征”
	•	V：被查询后实际返回的“信息内容”
它们是通过三个不同的线性变换（即三个不同的权重矩阵）从原始输入嵌入中得到的：

QKV 就是：问什么（Q）→ 找什么（K）→ 拿什么（V）
4. Multi-Head Attention 是怎么实现的？
你说对了核心逻辑：多个不同的 Q、K、V 映射。
可以补充表达：
Multi-Head Attention 是将 Q/K/V 分别投影成多个低维空间，做多次 Scaled Attention，然后将这些结果拼接起来再映射回原空间

5. 多头注意力机制的目的？
A: 多头注意力机制的核心目的在于：让模型从多个子空间、多个角度并行地关注序列中的不同语义关系，提升模型捕捉复杂特征的能力。例如，一个 head 可以关注语法结构，另一个关注实体依赖等。它提高了模型的信息表达能力与细粒度建模能力。

6.self-attention为什么要除以√d_k
A：因为在高维空间中，向量的点积值可能非常大，导致 softmax 输出太大，进而造成梯度消失问题。为了防止这种数值不稳定，Transformer 在计算 attention 时引入了缩放因子 1/√d_k，目的是把输入值缩放到一个合适的范围内，避免 softmax 饱和，稳定训练过程。（类似于归一化）



RNN 在训练过程中会出现梯度消失，是因为其参数在反向传播时要不断乘上链式导数，如果权重矩阵或激活函数的梯度小于1，这个乘积会指数级趋近于0，从而导致早期时间步的权重几乎无法更新，模型无法学习到长期依赖。这个问题是使用长序列训练普通 RNN 的最大障碍，典型解决方案包括使用 LSTM 或 GRU，它们通过门控机制保留关键信息流。

更多：
### 1、讲讲对Attention的理解？
参考回答：Attention机制是一种在处理时序相关问题的时候常用的技术，主要用于处理序列数据。它核心思想是在处理序列数据时，网络应该更关注输入中的重要部分，而忽略不重要的部分，它通过学习不同部分的权重，将输入的序列中的重要部分显式地加权，从而使得模型可以更好地关注与输出有关的信息。
在序列建模任务中，比如机器翻译、文本摘要、语言理解等，输入序列的不同部分可能具有不同的重要性。传统的循环神经网络（RNN）或卷积神经网络（CNN）在处理整个序列时，难以捕捉到序列中不同位置的重要程度，可能导致信息传递不够高效，特别是在处理长序列时表现更明显。
Attention机制的关键是引入一种机制来动态地计算输入序列中各个位置的权重，从而在每个时间步上，对输入序列的不同部分进行加权求和，得到当前时间步的输出。这样就实现了模型对输入中不同部分的关注度的自适应调整。

### 2、Attention的计算步骤是什么？
参考回答：具体的计算步骤如下：
	•	计算查询（Query）：查询是当前时间步的输入，用于和序列中其他位置的信息进行比较。
	•	计算键（Key）和值（Value）：键表示序列中其他位置的信息，值是对应位置的表示。键和值用来和查询进行比较。
	•	计算注意力权重：通过将查询和键进行内积运算，然后应用softmax函数，得到注意力权重。这些权重表示了在当前时间步，模型应该关注序列中其他位置的重要程度。
	•	加权求和：根据注意力权重将值进行加权求和，得到当前时间步的输出。

### 3、Attention机制和传统的Seq2Seq模型有什么区别？
参考回答：Seq2Seq模型是一种基于编码器-解码器结构的模型，主要用于处理序列到序列的任务，例如机器翻译、语音识别等。传统的Seq2Seq模型只使用编码器来捕捉输入序列的信息，而解码器只从编码器的最后状态中获取信息，并将其用于生成输出序列。而Attention机制则允许解码器在生成每个输出时，根据输入序列的不同部分给予不同的注意力，从而使得模型更好地关注到输入序列中的重要信息。
### 4、self-attention 和 target-attention的区别？
参考回答：self-attention是指在序列数据中，将当前位置与其他位置之间的关系建模。它通过计算每个位置与其他所有位置之间的相关性得分，从而为每个位置分配一个权重。这使得模型能够根据输入序列的不同部分的重要性，自适应地选择要关注的信息。
target-attention则是指将注意力机制应用于目标（或查询）和一组相关对象之间的关系。它用于将目标与其他相关对象进行比较，并将注意力分配给与目标最相关的对象。这种类型的注意力通常用于任务如机器翻译中的编码-解码模型，其中需要将源语言的信息对齐到目标语言。
因此，自注意力主要关注序列内部的关系，而目标注意力则关注目标与其他对象之间的关系。这两种注意力机制在不同的上下文中起着重要的作用，帮助模型有效地处理序列数据和相关任务。
### 5、self-attention的核心是什么？它的计算过程是什么？
参考回答：Self-Attention 的核心是建立在一种注意力机制上，它允许模型在处理序列数据时能够自动地"关注"到序列中的不同位置，并根据每个位置的重要性来加权考虑输入中其他位置的信息。
在传统的序列模型中（例如循环神经网络RNN和长短期记忆网络LSTM），信息的处理是顺序进行的，模型需要依次处理序列中的每个元素。这种方式在处理长距离依赖关系时可能会面临梯度消失或爆炸等问题。
而Self-Attention则可以一次性考虑序列中的所有位置，并计算每个位置与其他位置的相关性得分，这些得分将被用来对不同位置的表示进行加权平均。这使得模型能够轻松地捕捉长距离的依赖关系，而无需像传统序列模型那样通过多层堆叠来增加上下文的窗口。
在Transformer中，Self-Attention 被称为"Scaled Dot-Product Attention"，其计算过程如下：
	0.	对于输入序列中的每个位置，通过计算其与所有其他位置之间的相似度得分（通常通过点积计算）。
	0.	对得分进行缩放处理，以防止梯度爆炸。
	0.	将得分用softmax函数转换为注意力权重，以便计算每个位置的加权和。
	0.	使用注意力权重对输入序列中的所有位置进行加权求和，得到每个位置的自注意输出。
### 6、在常规attention中，一般有k=v，那self-attention 可以吗?
参考回答：self-attention实际只是attention中的一种特殊情况，因此k=v是没有问题的，也即K，V参数矩阵相同。实际上，在Transformer模型中，Self-Attention的典型实现就是k等于v的情况。Transformer中的Self-Attention被称为"Scaled Dot-Product Attention"，其中通过将词向量进行线性变换来得到Q、K、V，并且这三者是相等的。
### 7、目前主流的attention方法有哪些？
参考回答：讲自己熟悉的就可：
	•	Scaled Dot-Product Attention: 这是Transformer模型中最常用的Attention机制，用于计算查询向量（Q）与键向量（K）之间的相似度得分，然后使用注意力权重对值向量（V）进行加权求和。
	•	Multi-Head Attention: 这是Transformer中的一个改进，通过同时使用多组独立的注意力头（多个QKV三元组），并在输出时将它们拼接在一起。这样的做法允许模型在不同的表示空间上学习不同类型的注意力模式。
	•	Relative Positional Encoding: 传统的Self-Attention机制在处理序列时并未直接考虑位置信息，而相对位置编码引入了位置信息，使得模型能够更好地处理序列中不同位置之间的关系。
	•	Transformer-XL: 一种改进的Transformer模型，通过使用循环机制来扩展Self-Attention的上下文窗口，从而处理更长的序列依赖性。
### 8、self-attention 在计算的过程中，如何对padding位做mask？
参考回答：在 Attention 机制中，同样需要忽略 padding 部分的影响，这里以transformer encoder中的self-attention为例：self-attention中，Q和K在点积之后，需要先经过mask再进行softmax，因此，对于要屏蔽的部分，mask之后的输出需要为负无穷，这样softmax之后输出才为0。
### 9、深度学习中attention与全连接层的区别何在？
参考回答：这是个非常有意思的问题，要回答这个问题，我们必须重新定义一下Attention。Transformer Paper里重新用QKV定义了Attention。所谓的QKV就是Query，Key，Value。如果我们用这个机制来研究传统的RNN attention，就会发现这个过程其实是这样的：RNN最后一步的output是Q，这个Q query了每一个中间步骤的K。Q和K共同产生了Attention Score，最后Attention Score乘以V加权求和得到context。那如果我们不用Attention，单纯用全连接层呢？很简单，全链接层可没有什么Query和Key的概念，只有一个Value，也就是说给每个V加一个权重再加到一起（如果是Self Attention，加权这个过程都免了，因为V就直接是从raw input加权得到的。）
可见Attention和全连接最大的区别就是Query和Key，而这两者也恰好产生了Attention Score这个Attention中最核心的机制。而在Query和Key中，我认为Query又相对更重要，因为Query是一个锚点，Attention Score便是从过计算与这个锚点的距离算出来的。任何Attention based algorithm里都会有Query这个概念，但全连接显然没有。
最后来一个比较形象的比喻吧。如果一个神经网络的任务是从一堆白色小球中找到一个略微发灰的，那么全连接就是在里面随便乱抓然后凭记忆和感觉找，而attention则是左手拿一个白色小球，右手从袋子里一个一个抓出来，两两对比颜色，你左手抓的那个白色小球就是Query。
### 10、transformer中multi-head attention中每个head为什么要进行降维？
参考回答：在Transformer的Multi-Head Attention中，对每个head进行降维是为了增加模型的表达能力和效率。
每个head是独立的注意力机制，它们可以学习不同类型的特征和关系。通过使用多个注意力头，Transformer可以并行地学习多种不同的特征表示，从而增强了模型的表示能力。
然而，在使用多个注意力头的同时，注意力机制的计算复杂度也会增加。原始的Scaled Dot-Product Attention的计算复杂度为O(d^2)，其中d是输入向量的维度。如果使用h个注意力头，计算复杂度将增加到O(hd^2)。这可能会导致Transformer在处理大规模输入时变得非常耗时。
为了缓解计算复杂度的问题，Transformer中在每个head上进行降维。在每个注意力头中，输入向量通过线性变换被映射到一个较低维度的空间。这个降维过程使用两个矩阵：一个是查询（Q）和键（K）的降维矩阵W_q和W_k，另一个是值（V）的降维矩阵W_v。
通过降低每个head的维度，Transformer可以在保持较高的表达能力的同时，大大减少计算复杂度。降维后的计算复杂度为O(hd' ^ 2)，其中d'是降维后的维度。通常情况下，d'会远小于原始维度d，这样就可以显著提高模型的计算效率。
### 11、transformer在哪里做了权重共享，为什么可以做权重共享？
参考回答：ransformer在Encoder和Decoder中都进行了权重共享。
在Transformer中，Encoder和Decoder是由多层的Self-Attention Layer和前馈神经网络层交叉堆叠而成。权重共享是指在这些堆叠的层中，相同位置的层共用相同的参数。在Encoder中，所有的自注意力层和前馈神经网络层都共享相同的参数。这意味着每一层的自注意力机制和前馈神经网络都使用相同的权重矩阵来进行计算。这种共享保证了每一层都执行相同的计算过程，使得模型能够更好地捕捉输入序列的不同位置之间的关联性。在Decoder中，除了和Encoder相同的权重共享方式外，还存在另一种特殊的权重共享：Decoder的自注意力层和Encoder的自注意力层之间也进行了共享。这种共享方式被称为"masked self-attention"，因为在解码过程中，当前位置的注意力不能关注到未来的位置（后续位置），以避免信息泄漏。通过这种共享方式，Decoder可以利用Encoder的表示来理解输入序列并生成输出序列。权重共享的好处是大大减少了模型的参数数量，使得Transformer可以更有效地训练，并且更容易进行推理。此外，共享参数还有助于加快训练速度和提高模型的泛化能力，因为模型可以在不同位置共享并学习通用的特征表示。
### 12、transformer的点积模型做缩放的原因是什么？
参考回答：使用缩放的原因是为了控制注意力权重的尺度，以避免在计算过程中出现梯度爆炸的问题。
### 13、BERT用字粒度和词粒度的优缺点有哪些？
参考回答：BERT可以使用字粒度（character-level）和词粒度（word-level）两种方式来进行文本表示，它们各自有优缺点：
字粒度（Character-level）：
优点：处理未登录词（Out-of-Vocabulary，OOV）：字粒度可以处理任意字符串，包括未登录词，不需要像词粒度那样遇到未登录词就忽略或使用特殊标记。对于少见词和低频词，字粒度可以学习更丰富的字符级别表示，使得模型能够更好地捕捉词汇的细粒度信息。
缺点：计算复杂度高：使用字粒度会导致输入序列的长度大大增加，进而增加模型的计算复杂度和内存消耗。需要更多的训练数据：字粒度模型对于少见词和低频词需要更多的训练数据来学习有效的字符级别表示，否则可能会导致过拟合。
词粒度（Word-level）：
优点：计算效率高：使用词粒度可以大大减少输入序列的长度，从而降低模型的计算复杂度和内存消耗。学习到更加稳定的词级别表示：词粒度模型可以学习到更加稳定的词级别表示，特别是对于高频词和常见词，有更好的表示能力。
缺点：处理未登录词（OOV）：词粒度模型无法处理未登录词，遇到未登录词时需要采用特殊处理（如使用未登录词的特殊标记或直接忽略）。对于多音字等形态复杂的词汇，可能无法准确捕捉其细粒度的信息。
### 14、BERT的Encoder与Decoder掩码有什么区别？
参考回答：ncoder主要使用自注意力掩码和填充掩码，而Decoder除了自注意力掩码外，还需要使用编码器-解码器注意力掩码来避免未来位置信息的泄露。这些掩码操作保证了Transformer在处理自然语言序列时能够准确、有效地进行计算，从而获得更好的表现。
### 15、BERT用的是transformer里面的encoder还是decoder？
参考回答：BERT使用的是Transformer中的Encoder部分，而不是Decoder部分。Transformer模型由Encoder和Decoder两个部分组成。Encoder用于将输入序列编码为一系列高级表示，而Decoder用于基于这些表示生成输出序列。在BERT模型中，只使用了Transformer的Encoder部分，并且对其进行了一些修改和自定义的预训练任务，而没有使用Transformer的Decoder部分。
### 16、为什么BERT选择mask掉15%这个比例的词，可以是其他的比例吗？
参考回答：BERT选择mask掉15%的词是一种经验性的选择，是原论文中的一种选择，并没有一个固定的理论依据，实际中当然可以尝试不同的比例，15%的比例是由BERT的作者在原始论文中提出，并在实验中发现对于BERT的训练效果是有效的。
### 17、为什么BERT在第一句前会加一个[CLS] 标志?
参考回答：BERT在第一句前会加一个 [CLS] 标志，最后一层该位对应向量可以作为整句话的语义表示，从而用于下游的分类任务等。为什么选它？因为与文本中已有的其它词相比，这个无明显语义信息的符号会更“公平”地融合文本中各个词的语义信息，从而更好的表示整句话的语义。具体来说，self-attention是用文本中的其它词来增强目标词的语义表示，但是目标词本身的语义还是会占主要部分的，因此，经过BERT的12层，每次词的embedding融合了所有词的信息，可以去更好的表示自己的语义。而 [CLS] 位本身没有语义，经过12层，得到的是attention后所有词的加权平均，相比其他正常词，可以更好的表征句子语义。
### 18、BERT非线性的来源在哪里？
参考回答：主要来自两个地方：前馈层的gelu激活函数和self-attention。前馈神经网络层：在BERT的Encoder中，每个自注意力层之后都跟着一个前馈神经网络层。前馈神经网络层是全连接的神经网络，通常包括一个线性变换和一个非线性的激活函数，如gelu。这样的非线性激活函数引入了非线性变换，使得模型能够学习更加复杂的特征表示。self-attention layer：在自注意力层中，查询（Query）、键（Key）、值（Value）之间的点积得分会经过softmax操作，形成注意力权重，然后将这些权重与值向量相乘得到每个位置的自注意输出。这个过程中涉及了softmax操作，使得模型的计算是非线性的。
### 19、BERT训练时使用的学习率 warm-up 策略是怎样的？为什么要这么做？
参考回答：在BERT的训练中，使用了学习率warm-up策略，这是为了在训练的早期阶段增加学习率，以提高训练的稳定性和加快模型收敛。学习率warm-up策略的具体做法是，在训练开始的若干个步骤（通常是一小部分训练数据的迭代次数）内，将学习率逐渐从一个较小的初始值增加到预定的最大学习率。在这个过程中，学习率的变化是线性的，即学习率在warm-up阶段的每个步骤按固定的步幅逐渐增加。学习率warm-up的目的是为了解决BERT在训练初期的两个问题：
不稳定性：在训练初期，由于模型参数的随机初始化以及模型的复杂性，模型可能处于一个较不稳定的状态。此时使用较大的学习率可能导致模型的参数变动太大，使得模型很难收敛，学习率warm-up可以在这个阶段将学习率保持较小，提高模型训练的稳定性。
避免过拟合：BERT模型往往需要较长的训练时间来获得高质量的表示。如果在训练的早期阶段就使用较大的学习率，可能会导致模型在训练初期就过度拟合训练数据，降低模型的泛化能力。通过学习率warm-up，在训练初期使用较小的学习率，可以避免过度拟合，等模型逐渐稳定后再使用较大的学习率进行更快的收敛。
### 20、在BERT应用中，如何解决长文本问题？
参考回答：在BERT应用中，处理长文本问题有以下几种常见的解决方案：
	•	截断与填充：将长文本截断为固定长度或者进行填充。BERT模型的输入是一个固定长度的序列，因此当输入的文本长度超过模型的最大输入长度时，需要进行截断或者填充。通常，可以根据任务的要求，选择适当的最大长度，并对文本进行截断或者填充，使其满足模型输入的要求。
	•	Sliding Window：将长文本分成多个短文本，然后分别输入BERT模型。这种方法被称为Sliding Window技术。具体来说，将长文本按照固定的步长切分成多个片段，然后分别输入BERT模型进行处理。每个片段的输出可以进行进一步的汇总或者融合，得到最终的表示。
	•	Hierarchical Model：使用分层模型来处理长文本，其中底层模型用于处理短文本片段，然后将不同片段的表示进行汇总或者融合得到整个长文本的表示。这样的分层模型可以充分利用BERT模型的表示能力，同时处理长文本。
	•	Longformer、BigBird等模型：使用专门针对长文本的模型，如Longformer和BigBird。这些模型采用了不同的注意力机制，以处理超长序列，并且通常在处理长文本时具有更高的效率。
	•	Document-Level Model：将文本看作是一个整体，而不是将其拆分成句子或段落，然后输入BERT模型进行处理。这样的文档级模型可以更好地捕捉整个文档的上下文信息，但需要更多的计算资源。
四、小结
注意力机制（Attention）和变换器（Transformer）是自然语言处理（NLP）领域中的两个重要概念，尤其在机器翻译和其他序列到序列任务中扮演了关键角色。"注意力变换器"（Attention Transformer）通常指的是使用注意力机制的Transformer模型。
